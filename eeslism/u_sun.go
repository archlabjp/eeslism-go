/* ================================================================

 SUNLIB

  太陽位置および日射量計算用ライブラリ－
  （宇田川、パソコンによる空気調和計算法、プログラム4.1の C 言語版, ANSI C 版）

---------------------------------------------------------------- */

package eeslism

import (
	"math"
)

/*
Sunint (Sun Initialization)

この関数は、太陽位置と日射量計算に必要な初期定数を設定します。
緯度、地球の軌道離心率、太陽定数などの地理的・天文学的パラメータを初期化します。

建築環境工学的な観点:
- **地理的パラメータの重要性**: 建物の日射熱取得量や日影の状況は、
  その建物の位置（緯度`Lat`）に大きく依存します。
  緯度が高い地域では、冬期の日射取得が重要になり、夏期は日射遮蔽が課題となります。
  `Slat`, `Clat`, `Tlat`は、緯度から導出される三角関数値であり、
  太陽高度角や方位角の計算に用いられます。
- **太陽定数 (Isc)**:
  太陽定数は、地球の大気圏外で太陽光線に垂直な面が受ける単位面積あたりの日射エネルギー量です。
  これは、地球に到達する太陽エネルギーの最大値を示し、
  日射量計算の基礎となります。
  `UNIT`が`SI`（国際単位系）かどうかに応じて値が設定されるのは、
  単位系によって太陽定数の値が異なるためです。
- **日射量計算の基礎**: この関数で設定される初期定数は、
  その後の太陽位置計算（太陽高度角、方位角）や、
  大気圏外日射量、地表に到達する日射量などの計算の出発点となります。
  これらの正確な計算は、建物の日射熱取得、日影、昼光利用、
  そして太陽光発電システムの発電量予測に不可欠です。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計や日射遮蔽計画、
そして再生可能エネルギーシステムの導入検討を行うための基礎的な役割を果たします。
*/
func Sunint() {
	var Rd float64 = math.Pi / 180.0
	Slat = math.Sin(Lat * Rd)
	Clat = math.Cos(Lat * Rd)
	Tlat = math.Tan(Lat * Rd)
	if UNIT == "SI" {
		Isc = 1370.0
	} else {
		Isc = 1178.0
	}
}

/*
FNDecl (Function for Declination Angle)

この関数は、太陽の赤緯（Declination Angle）を計算します。
赤緯は、地球の公転に伴う太陽の南北方向への見かけの移動を表す角度であり、
太陽高度角の計算に不可欠な要素です。

建築環境工学的な観点:
- **赤緯の季節変化**: 地球の地軸が公転面に対して傾いているため、
  太陽の赤緯は季節によって変化します。
  夏至には最大（約+23.45度）、冬至には最小（約-23.45度）となり、
  春分・秋分には0度になります。
  この季節変化が、日中の太陽高度や日照時間の変化を引き起こし、
  建物の日射熱取得量や日影の状況に大きな影響を与えます。
- **日射熱取得の予測**: 赤緯が分かると、特定の時刻における太陽高度角を計算できます。
  太陽高度角が高いほど、垂直面（壁面）への日射入射角が小さくなり、
  日射熱取得量が増加する傾向があります。
  逆に、太陽高度角が低い冬期には、南面窓からの日射取得が暖房負荷軽減に寄与します。
- **日影計算の基礎**: 建物の日影の形状や範囲は、太陽の赤緯によって大きく変化します。
  特に、隣棟間隔の検討や、日影規制の遵守において、正確な赤緯の計算は不可欠です。
- **数式モデル**: `0.397949 * math.Sin(2.0*math.Pi*(float64(N)-81.0)/365.0)` の式は、
  赤緯の年間変化を近似する一般的な数式モデルです。
  `N`は通日（1月1日を1とする）を表し、地球の公転周期（365日）と地軸の傾きを考慮しています。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
そして日影計算を行うための基礎的な役割を果たします。
*/
func FNDecl(N int) float64 {
	return math.Asin(0.397949 * math.Sin(2.0*math.Pi*(float64(N)-81.0)/365.0))
}

/*
FNE (Function for Equation of Time)

この関数は、均時差（Equation of Time）を計算します。
均時差は、平均太陽時と真太陽時とのずれを表すもので、
太陽位置の正確な計算に不可欠な要素です。

建築環境工学的な観点:
- **均時差の発生要因**: 地球の公転軌道が楕円であることと、
  地軸が公転面に対して傾いていることの二つの要因によって発生します。
  これにより、日時計が示す時刻（真太陽時）と、
  私たちが普段使っている時計の時刻（平均太陽時）との間にずれが生じます。
  このずれは年間で約±16分程度の範囲で変動します。
- **太陽位置の正確な把握**: 建物の日射熱取得量や日影の状況を正確に予測するためには、
  特定の時刻における太陽の真の方向（太陽高度角、方位角）を知る必要があります。
  均時差を考慮することで、平均太陽時から真太陽時を導出し、
  より正確な太陽位置の計算が可能となります。
- **日射熱取得と日影計算への影響**: 均時差を考慮しない場合、
  日射熱取得量の計算や日影の予測に誤差が生じる可能性があります。
  特に、日射遮蔽部材の設計や、太陽光発電システムの最適配置を検討する際には、
  このわずかな時間のずれが重要な意味を持つことがあります。
- **数式モデル**: `0.1645*math.Sin(2.0*B) - 0.1255*math.Cos(B) - 0.025*math.Sin(B)` の式は、
  均時差の年間変化を近似する一般的な数式モデルです。
  `B`は通日`N`から導出される角度であり、地球の公転周期を考慮しています。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
そして日影計算を行うための基礎的な役割を果たします。
*/
func FNE(N int) float64 {
	var B float64 = 2.0 * math.Pi * (float64(N) - 81.0) / 365.0
	return 0.1645*math.Sin(2.0*B) - 0.1255*math.Cos(B) - 0.025*math.Sin(B)
}

/*
FNSro (Function for Extraterrestrial Solar Radiation)

この関数は、大気圏外日射量（Extraterrestrial Solar Radiation）を計算します。
大気圏外日射量は、地球の大気圏外で太陽光線に垂直な面が受ける日射量であり、
地表に到達する日射量計算の基礎となります。

建築環境工学的な観点:
- **地球と太陽の距離変化**: 地球の公転軌道が楕円であるため、
  地球と太陽の距離は年間を通じて変化します。
  地球が太陽に最も近づく近日点（1月上旬頃）では日射量が最大となり、
  最も遠ざかる遠日点（7月上旬頃）では最小となります。
  この距離の変化が、大気圏外日射量の季節変化を引き起こします。
- **日射量計算の基礎**: 地表に到達する日射量は、
  この大気圏外日射量から、大気による吸収・散乱・反射の影響を差し引くことで計算されます。
  したがって、大気圏外日射量を正確に把握することは、
  建物の日射熱取得量や太陽光発電システムの発電量予測の出発点となります。
- **数式モデル**: `Isc * (1.0 + 0.033*math.Cos(2.0*math.Pi*float64(N)/365.0))` の式は、
  地球と太陽の距離変化による大気圏外日射量の年間変化を近似する一般的な数式モデルです。
  `Isc`は太陽定数、`N`は通日を表し、地球の公転周期を考慮しています。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
そして太陽光発電システムの発電量予測を行うための基礎的な役割を果たします。
*/
func FNSro(N int) float64 {
	return Isc * (1.0 + 0.033*math.Cos(2.0*math.Pi*float64(N)/365.0))
}

/*
FNTtas (Function for True Solar Time from Local Standard Time)

この関数は、地方標準時（Local Standard Time, LST）から真太陽時（True Solar Time, TST）を計算します。
真太陽時は、太陽が南中する時刻を正午とする時刻系であり、
太陽位置の正確な計算に不可欠な要素です。

建築環境工学的な観点:
- **時刻系の違い**: 私たちが普段使用している時刻（地方標準時）は、
  経度15度ごとに設定された標準子午線に基づいています。
  しかし、太陽の動きは地球の自転と公転によって決まるため、
  実際の太陽の南中時刻は、標準子午線からの経度差や均時差によって地方標準時とずれます。
- **真太陽時の重要性**: 建物の日射熱取得量や日影の状況は、
  太陽の真の方向（太陽高度角、方位角）に依存します。
  真太陽時を用いることで、太陽が実際にどの方向にあるかを正確に把握でき、
  日射熱取得のピーク時刻や日影の発生時刻などを正確に予測できます。
- **計算要素**: この関数は、以下の要素を考慮して真太陽時を計算します。
  - `Tt`: 地方標準時（入力値）。
  - `E`: 均時差（`FNE`関数で計算）。
  - `Lon`: 観測地点の経度。
  - `Ls`: 標準子午線の経度。
  ` (Lon - Ls) / 15.0` は、経度差による時刻のずれを時間単位で表したものです。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
そして日影計算を行うための基礎的な役割を果たします。
*/
func FNTtas(Tt float64, E float64) float64 {
	return Tt + E + (Lon-Ls)/15.0
}

/*
FNTt (Function for Local Standard Time from True Solar Time)

この関数は、真太陽時（True Solar Time, TST）から地方標準時（Local Standard Time, LST）を計算します。
これは、主に真太陽時を基準とした計算結果を、一般的な時刻系に変換する際に用いられます。

建築環境工学的な観点:
- **時刻系の変換**: 太陽位置や日射量に関する計算は、真太陽時を基準に行われることが多いです。
  しかし、建物の運用や居住者の活動は地方標準時を基準に行われるため、
  計算結果を実用的な時刻系に変換する必要があります。
  この関数は、その逆変換を行うことで、シミュレーション結果をより分かりやすく提示するために利用されます。
- **計算要素**: この関数は、以下の要素を考慮して地方標準時を計算します。
  - `Ttas`: 真太陽時（入力値）。
  - `E`: 均時差（`FNE`関数で計算）。
  - `Lon`: 観測地点の経度。
  - `Ls`: 標準子午線の経度。
  ` (Lon - Ls) / 15.0` は、経度差による時刻のずれを時間単位で表したものです。

この関数は、建物の日射環境シミュレーションの結果を、
実用的な時刻系で解釈し、設計や運用に役立てるための補助的な役割を果たします。
*/
func FNTt(Ttas float64, E float64) float64 {
	return Ttas - E - (Lon-Ls)/15.0
}

/*
FNTtd (Function for Day Length)

この関数は、日長（Day Length）、すなわち日の出から日の入りまでの時間を計算します。
日長は、日照時間や日射熱取得量を評価する上で重要な要素です。

建築環境工学的な観点:
- **日照時間の季節変化**: 日長は、緯度と太陽の赤緯によって変化します。
  夏期には日長が長く、冬期には短くなります。
  この季節変化は、建物の日照条件や日射熱取得量に直接影響を与えます。
- **日照シミュレーションの基礎**: 日長を正確に計算することは、
  建物の日照シミュレーションや、日影の発生時間を予測する上で不可欠です。
  特に、冬期の日照確保や、夏期の日射遮蔽計画を検討する際に重要となります。
- **計算要素**: この関数は、以下の要素を考慮して日長を計算します。
  - `Decl`: 太陽の赤緯（`FNDecl`関数で計算）。
  - `Tlat`: 緯度の正接（`Sunint`関数で設定）。
  - `Cws = -Tlat * math.Tan(Decl)`: 日の出・日の入り時の時角の余弦を計算するための補助変数。
  `math.Acos(Cws)`は、日の出・日の入り時の時角をラジアンで返します。
  この時角を時間単位に変換することで日長が得られます。
- **極端なケースの考慮**: `Cws >= 1.0`（極夜）の場合に`Ttd = 0.0`、
  `Cws <= -1.0`（白夜）の場合に`Ttd = 24.0`とすることで、
  極地における日長を適切に処理しています。

この関数は、建物の日照環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
そして日影計算を行うための基礎的な役割を果たします。
*/
func FNTtd(Decl float64) float64 {
	var Tlat float64
	var Cws, Ttd float64
	Cws = -Tlat * math.Tan(Decl)
	if 1.0 > Cws && Cws > -1.0 {
		Ttd = 7.6394 * math.Acos(Cws)
	} else {
		if Cws >= 1.0 {
			Ttd = 0.0
		} else {
			Ttd = 24.0
		}
	}
	return Ttd
}

var __Solpos_Sdecl, __Solpos_Sld, __Solpos_Cld float64
var __Solpos_Ttprev float64 = 25.0

/*
Solpos (Solar Position Calculation)

この関数は、与えられた時刻と日付における太陽の正確な位置（太陽高度角、方位角）を計算します。
これは、建物の日射熱取得、日影、昼光利用、そして太陽光発電システムの性能評価に不可欠な情報です。

建築環境工学的な観点:
- **太陽高度角 (solh)**:
  地平線から太陽の中心までの角度です。
  太陽高度角が高いほど、垂直面（壁面）への日射入射角が小さくなり、
  日射熱取得量が増加する傾向があります。
  また、昼光利用の観点からは、太陽高度角が高いほど窓からの光の取り込みが効率的になります。
- **太陽方位角 (solA)**:
  真北（または真南）を基準とした太陽の水平方向の角度です。
  太陽方位角は、建物の開口部や日射遮蔽部材の向きを決定する上で重要です。
  例えば、夏季の西日対策として、西面窓に適切な日射遮蔽を設ける必要があります。
- **計算要素**: この関数は、以下の要素を考慮して太陽位置を計算します。
  - `Ttas`: 真太陽時（`FNTtas`関数で計算）。
  - `Decl`: 太陽の赤緯（`FNDecl`関数で計算）。
  - `Slat`, `Clat`: 緯度の正弦、余弦（`Sunint`関数で設定）。
  - `W`: 時角。真太陽時を角度に変換したもので、太陽が南中する時刻を0度とします。
- **日射熱取得と日影計算への応用**: 計算された太陽高度角と方位角は、
  建物の各面が受ける日射量を計算したり、
  建物の形状や周囲の障害物による日影の範囲を特定したりするために用いられます。
  これにより、建物の熱負荷を正確に予測し、
  パッシブソーラー設計や日射遮蔽計画を最適化できます。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
昼光利用、そして太陽光発電システムの発電量予測を行うための基礎的な役割を果たします。
*/
func Solpos(Ttas float64, Decl float64) (Sh float64, Sw float64, Ss float64, solh float64, solA float64) {
	const PI float64 = math.Pi
	var Ch, Ca, Sa, W float64

	if Ttas < __Solpos_Ttprev {
		__Solpos_Sdecl = math.Sin(Decl)
		__Solpos_Sld = Slat * __Solpos_Sdecl
		__Solpos_Cld = Clat * math.Cos(Decl)
	}

	W = (Ttas - 12.0) * 0.2618
	Sh = __Solpos_Sld + __Solpos_Cld*math.Cos(W)
	solh = math.Asin(Sh) / PI * 180.0

	if Sh > 0.0 {
		Ch = math.Sqrt(1.0 - Sh*Sh)
		Ca = (Sh*Slat - __Solpos_Sdecl) / (Ch * Clat)
		var fW0 float64
		if W > 0.0 {
			fW0 = 1.0
		} else {
			fW0 = -1.0
		}
		solA = fW0 * math.Acos(Ca) / PI * 180.0
		Sa = (W / math.Abs(W)) * math.Sqrt(1.0-Ca*Ca)
		Sw = Ch * Sa
		Ss = Ch * Ca
	} else {
		Sh = 0.0
		Sw = 0.0
		Ss = 0.0
		solh = 0.0
		solA = 0.0
	}

	__Solpos_Ttprev = Ttas

	return Sh, Sw, Ss, solh, solA
}

/*
Srdclr (Solar Radiation Calculation for Clear Sky)

この関数は、快晴時における地表に到達する直達日射量と天空日射量を計算します。
これは、日射熱取得量や太陽光発電システムの発電量予測の基礎となります。

建築環境工学的な観点:
- **直達日射量 (Idn)**:
  太陽から直接地表に到達する日射成分です。
  建物の窓や壁面に直接入射し、日射熱取得の主要な要因となります。
  日射遮蔽部材の設計や、太陽光発電パネルの最適配置を検討する上で重要です。
- **天空日射量 (Isky)**:
  大気中の水蒸気や塵などによって散乱され、全方向から地表に到達する日射成分です。
  直達日射とは異なり、日射遮蔽部材による影響を受けにくいため、
  窓からの昼光利用や、日射遮蔽が難しい部位（例: 北面窓）の日射熱取得に影響します。
- **大気透過率 (P)**:
  大気透過率は、大気を通過する際に日射がどれだけ減衰するかを示す指標です。
  大気中の水蒸気量や塵の量、標高などによって変化します。
  `math.Pow(P, 1.0/Sh)` のように、太陽高度角（`Sh`）に応じて透過率が変化するモデルは、
  太陽光が斜めに入射するほど大気を通過する距離が長くなり、減衰が大きくなることを考慮しています。
- **日射量計算の重要性**: 建物の熱負荷計算において、日射熱取得は非常に大きな割合を占めます。
  特に夏季の冷房負荷や冬季の暖房負荷を正確に予測するためには、
  直達日射量と天空日射量を適切に評価することが不可欠です。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
昼光利用、そして太陽光発電システムの発電量予測を行うための基礎的な役割を果たします。
*/
func Srdclr(Io float64, P float64, Sh float64, Idn *float64, Isky *float64) {
	if Sh > 0.001 {
		*Idn = Io * math.Pow(P, 1.0/Sh)
		*Isky = Sh * (Io - *Idn) * (0.66 - 0.32*Sh) * (0.5 + (0.4-0.3*P)*Sh)
	} else {
		*Idn = 0.0
		*Isky = 0.0
	}
}

/*
Dnsky (Diffuse and Sky Radiation Calculation)

この関数は、全天日射量から直達日射量と天空日射量を分離して計算します。
これは、日射熱取得量や太陽光発電システムの発電量予測の基礎となります。

建築環境工学的な観点:
- **全天日射量の分解**: 地表で観測される日射量（全天日射量`Ihol`）は、
  直達日射量と天空日射量の合計です。
  建物の熱負荷計算や太陽光発電システムの発電量予測では、
  これらの成分を分離して扱うことが重要です。
  なぜなら、直達日射は日射遮蔽の影響を大きく受けるのに対し、
  天空日射は比較的影響を受けにくいためです。
- **日射量モデル**: この関数は、全天日射量と太陽高度角（`Sh`）に基づいて、
  直達日射量（`Idn`）と天空日射量（`Isky`）を推定するモデルを実装しています。
  `Kt`（清澄度指数）は、大気の透明度を示す指標であり、
  日射量の分解に用いられます。
  `Kt >= 0.5163+(0.333+0.00803*Sh)*Sh` のような条件分岐は、
  大気の状態（快晴、薄曇りなど）に応じて日射量の分解モデルを切り替えることを示唆します。
- **日射熱取得と熱負荷**: 直達日射は、窓を透過して室内に直接入射し、
  大きな日射熱取得をもたらします。
  一方、天空日射は、窓や壁面全体から入射し、
  特に曇天時や日陰になる部分でも一定の熱負荷をもたらします。
  これらの成分を正確に把握することで、
  建物の熱負荷をより詳細に分析し、適切な日射遮蔽や断熱計画を策定できます。

この関数は、建物の日射環境を正確にモデル化し、
パッシブソーラー設計、日射遮蔽計画、
昼光利用、そして太陽光発電システムの発電量予測を行うための基礎的な役割を果たします。
*/
func Dnsky(Io float64, Ihol float64, Sh float64, Idn *float64, Isky *float64) {
	if Sh > 0.001 {
		Kt := Ihol / (Io * Sh)
		if Kt >= 0.5163+(0.333+0.00803*Sh)*Sh {
			*Idn = (-0.43 + 1.43*Kt) * Io
		} else {
			*Idn = (2.277 + (-1.258+0.2396*Sh)*Sh) * (Kt * Kt * Kt) * Io
		}
		*Isky = Ihol - *Idn*Sh
	} else {
		*Idn = 0.0
		*Isky = Ihol
	}
}
