package eeslism

var __Intgtsup_ic int = 0

/*
Intgtsup (Interpolate Ground Temperature for Supply Water)

この関数は、各月の給水温度データ（`Tsupw`）を3次スプライン補間を用いて、
年間を通じた任意の日の給水温度を推定します。

建築環境工学的な観点:
- **給水温度の季節変動**: 給水温度は、
  地中温度や水源の温度に影響され、年間を通じて変動します。
  給湯負荷計算や、地中熱交換器の性能評価において、
  正確な給水温度のデータは不可欠です。
- **データ補間の必要性**: 気象データのように毎時データが提供されない場合でも、
  月ごとの平均値などから日ごとの値を推定する必要があります。
  3次スプライン補間は、滑らかな曲線でデータを補間するため、
  より現実的な給水温度の変動をモデル化できます。
- **スプライン補間の利用**: `spline`関数を呼び出すことで、
  与えられた離散的なデータ点（各月の給水温度）から、
  連続的な給水温度の曲線を作成し、
  任意の日の給水温度を推定します。
- **初期化の考慮**: `__Intgtsup_ic == 0` の条件は、
  スプライン補間のための初期設定（`x`, `y`配列の準備）を一度だけ行うことを意味します。
  これにより、計算効率を向上させます。

この関数は、建物のエネルギーシミュレーションにおいて、
給水温度の季節変動を正確にモデル化し、
給湯負荷計算や、地中熱利用システムの性能評価を行うための重要な役割を果たします。
*/
func Intgtsup(Nday int, Tsupw []float64) float64 {
	var h, b, d, g, u [13]float64
	var r, x, y [14]float64
	var n, Mo int
	var y1 float64

	if __Intgtsup_ic == 0 {
		n = 13
		x[0], x[13] = -15.0, 380.0
		for Mo = 1; Mo <= 12; Mo++ {
			x[Mo] = float64(FNNday(Mo, 15))
			y[Mo] = Tsupw[Mo-1]
			y[0], y[13] = Tsupw[11], Tsupw[0]
		}

		__Intgtsup_ic = 1
	}

	y1 = spline(n, x[:], y[:], float64(Nday), h[:], b[:], d[:], g[:], u[:], r[:])
	return y1
}

/*
spline (Cubic Spline Interpolation Function)

この関数は、与えられた離散的なデータ点（`x`, `y`）に基づいて、
3次スプライン補間を行い、
任意の点`x1`における補間値`y1`を計算します。

建築環境工学的な観点:
- **データ補間の必要性**: 建物のエネルギーシミュレーションでは、
  気象データや運用スケジュールなど、
  離散的なデータ点しか得られない場合があります。
  しかし、シミュレーションは連続的な時間軸で進行するため、
  これらのデータを補間して連続的な値を得る必要があります。
  3次スプライン補間は、
  データ点間を滑らかな曲線で結ぶため、
  より現実的な物理現象の変動をモデル化できます。
- **滑らかな曲線**: 3次スプライン補間は、
  各区間で3次多項式を用いてデータを補間し、
  データ点での関数の値、1次導関数、2次導関数が連続になるようにします。
  これにより、補間された曲線が滑らかになり、
  物理的な不連続性を避けることができます。
- **気象データ処理への応用**: 給水温度の補間（`Intgtsup`関数）のように、
  月ごとの平均値から日ごとの値を推定する際に用いられます。
  これにより、より詳細な時間ステップでのシミュレーションが可能になります。

この関数は、建物のエネルギーシミュレーションにおいて、
離散的なデータを連続的なデータに変換し、
シミュレーションの精度を向上させるための重要な役割を果たします。
*/
func spline(n int, x, y []float64, x1 float64, h, b, d, g, u, r []float64) float64 {
	i, i1, k := -1, 0, 0
	var y1, qi, si, xx float64

	// 区間の決定
	for i1 = 1; i1 < n && i < 0; i1++ {
		if x1 < x[i1] {
			i = i1 - 1
		}
	}
	if i < 0 {
		i = n - 1
	}

	// ステップ１
	for i1 = 0; i1 < n; i1++ {
		h[i1] = x[i1+1] - x[i1]
	}
	for i1 = 1; i1 < n; i1++ {
		b[i1] = 2.0 * (h[i1] + h[i1-1])
		d[i1] = 3.0 * ((y[i1+1]-y[i1])/h[i1] - (y[i1]-y[i1-1])/h[i1-1])
	}

	// ステップ２
	g[1] = h[1] / b[1]
	for i1 = 2; i1 < n-1; i1++ {
		g[i1] = h[i1] / (b[i1] - h[i1-1]*g[i1-1])
	}
	u[1] = d[1] / b[1]
	for i1 = 2; i1 < n; i1++ {
		u[i1] = (d[i1] - h[i1-1]*u[i1-1]) / (b[i1] - h[i1-1]*g[i1-1])
	}

	// ステップ３
	if i > 1 {
		k = i
	} else {
		k = 1
	}
	r[0] = 0.0
	r[n] = 0.0
	r[n-1] = u[n-1]
	for i1 = n - 2; i1 >= k; i1-- {
		r[i1] = u[i1] - g[i1]*r[i1+1]
	}

	// ステップ４
	xx = x1 - x[i]
	qi = (y[i+1]-y[i])/h[i] - h[i]*(r[i+1]+2.0*r[i])/3.0
	si = (r[i+1] - r[i]) / (3.0 * h[i])
	y1 = y[i] + xx*(qi+xx*(r[i]+si*xx))

	return y1
}
